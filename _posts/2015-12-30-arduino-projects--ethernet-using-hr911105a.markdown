---
layout: post
title: "Arduino Projects - Ethernet using HR911105A"
date: "2015-12-30"
comments: true
description: Tonight I decided to give Ethernet interfacing with the Arduino a go.
share: true
author: nathan
tags:
 - arduino
 - ethernet
---

## Introduction

I've been putting off learning about interfacing for a while now. It isn't because I don't want to learn it though; In fact it's probably the part of learning all of this that I was looking most forward to. No the reason I've been putting it off is purely due to the difficulty I've had trying to find a good, concise explanation of how it all works. I'm not content just loading in the interfacing libraries and accepting that as complete; I would really like to understand what is actually happening on each pin that I'm interfacing with and maybe even understand what the driver is doing.

## The Module

So lets get started! The module I purchased to work with is a `Duinotech` board sporting a `HanRun HR911105A RJ45 connector` and the `ENC28J60 Ethernet controller`.

![Ethernet Board]({{ site.url }}/images/posts/arduino-ethernet-board.jpg)

The first thing I did was look up the datasheet for the [ENC28J60 Ethernet controller](http://ww1.microchip.com/downloads/en/DeviceDoc/39662e.pdf). I was looking for detailed information on what each of the Ten interface pins on the board did and was happy to find that almost all the information I needed was available in the document provided.

Some of the key features the controller offers that I'm interested in are:

1. `Fully Compatible with 10/100/1000Base-T Networks` - The interface can provide full gigabit speeds.

2. `Supports Full and Half-Duplex modes` - Bi-directional simultaneous communication can occur on the same port, though I don't think the Arduino won't be-able to utilize this due to its single core/one operation at a time limitation.

3.  `SPI Interface with Clock Speeds up to 20 MHz` - SPI (Serial Peripheral Interface) will be the main way I communicate with the module. I already know there's a very extensive [SPI library](https://www.arduino.cc/en/Reference/SPI) available that I can learn with.

4. `8-Kbyte Transmit/Receive Packet Dual Port SRAM` - Allows for latching (in SRAM // Static random-access memory) and queuing of packets and data when up to 8-Kbytes. Again, I don't think this will be relevant to me but it's still nice to know about.

5.  `Supports Unicast, Multicast and Broadcast Packets` - Self explanatory and expected on most interfaces these days.

6. `WOL or Magic Packet` - Wake on LAN, another neat feature I'd love to explore on the board.

## Pin Description

Below is the schematic provided for the `ENC28J60 Ethernet controller`. There are only a couple pins that we have direct access to via the Pin headers, I'll try to explain as best I can what each of these pins are and what they do.

![Ethernet Controller Schematic]({{ site.url }}/images/posts/arduino-controller-schem.png)

1. `CLKOUT` - The Programmable clock output pin is provided for use as the host controller clock or as a clock source for other devices in the system.
* Has an internal `Prescaler` which can divide the output by 1, 2, 3, 4 or 8. A `Prescaler` is used to reduce a high frequency electrical signal to a lower frequency by integer division.

2. `INT` - Interrupt output pin signals the occurrence of an interrupt event to the host controller.

3. `WOL` - Wake on Lan pin which can be used to push a magic packet through to the Ethernet interface connected. There's some interesting examples of this [here](http://playground.arduino.cc/Main/ArduinoWaker).

4. `SO` - Also defined as `MISO (Master In Slave Out)` and is used as the Slave line for sending data to the master. The master in this case is normally the Arduino or microcontroller.

5. `SI` - Also defined as `MOSI (Master Out Slave In)` and is used as the Master line for sending data to the peripherals.

6. `SCK` - The Serial clock which synchronizes the data transmission generated by the master.

7. `CS` - Chip select the input pin for the SPI interface. It is held low while any operation is performed and returned high when finished.

8. `RESET` - Active low device that resets the input.

9. `VCC` - 3.3V supply input.

10. `GND` - Grounding pin.

If you're interested in the full block diagram for the controller, it can be seen below. Take note of the various pin labels we just discussed and use them to work out how the system all comes together.

![Controller Block Diagram]({{ site.url }}/images/posts/arduino-controller-block-diagram.png)

## Serial Peripheral Interface (SPI)

Commands and data are sent to the device via the `SI pin`, with data being clocked in on the rising edge of `SCK`. Data is driven out on the `SO line` on the falling edge of `SCK`. The `CS pin` must be held low while any operation is performed and returned high when finished.

Below is a timeline displaying the Pin states for both input and output.

![Input Output]({{ site.url }}/images/posts/arduino-controller-input-output.png)

These interfaces are mapped to the following ports on the Arduino Uno. You can find the correct pins for other boards under Connections [here](https://www.arduino.cc/en/Reference/SPI). Note that the ENC28J60 controller uses a different pin for CS than the normal pin 10 (SS).

1. `SI` Pin -> Digital `Pin 11` OR `ICSP-4`

2. `SO` Pin -> Digital `Pin 12` OR `ICSP-1`

3. `SCK` Pin -> Digital `Pin 13` OR `ICSP-3`

4. `CS` Pin -> Digital `Pin 8`

`NOTE` You can also use the Reset, Ground and 3.3V pins on the ICSP interface. Else just use the normal pins. You can safely ignore the `RESET pin` for most examples.

![ICSP]({{ site.url }}/images/posts/arduino-controller-icsp.png)

## Ethercard Libraries + Examples

In order to get our device communicating we'll need to use a library called `Ethercard`. It can be downloaded from here:

{% highlight c %}
https://github.com/jcw/ethercard
{% endhighlight c %}

Once you've downloaded the zip, place the contents in your Arduino `libraries` folder. The contents of the `ethercard` folder comes with a couple examples that we'll be using to first confirm that our interfacing is correct.

Go ahead and open up the `testDHCP sketch` under examples and upload the code to your Arduino. Connect a networked Ethernet cable to your Ethernet module and fire up the serial monitor. You will also need to set the `baud rate to 57600` (as specified in the code).

If all went well you should receive the following serial output indicating that you've successfully been assigned a DHCP address (your IP values will vary obviously).

{% highlight c %}
[testDHCP]
MAC: 74:69:69:2D:30:31
Setting up DHCP
MyIP: 192.168.188.53
Netmask: 255.255.255.0
GW IP: 192.168.188.254
DNS IP: 192.168.188.254
{% endhighlight c %}

Yay! We got it working. That's a really simple example though, and we still don't really know how it's working. Next we'll take a look at the code and try to build our own code from scratch.

## Build a Webserver

tbc
