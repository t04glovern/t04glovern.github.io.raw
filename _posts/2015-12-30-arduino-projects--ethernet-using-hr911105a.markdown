---
layout: post
title: "Arduino Projects - Ethernet using HR911105A"
date: "2015-12-30"
comments: true
description: Tonight I decided to give Ethernet interfacing with the Arduino a go.
share: true
author: nathan
tags:
 - arduino
 - ethernet
---

## Introduction

I've been putting off learning about interfacing for a while now. It isn't because I don't want to learn it though; In fact it's probably the part of learning all of this that I was looking most forward to. No the reason I've been putting it off is purely due to the difficulty I've had trying to find a good, concise explanation of how it all works. I'm not content just loading in the interfacing libraries and accepting that as complete; I would really like to understand what is actually happening on each pin that I'm interfacing with and maybe even understand what the driver is doing.

## The Module

So lets get started! The module I purchased to work with is a `Duinotech` board sporting a `HanRun HR911105A RJ45 connector` and the `ENC28J60 Ethernet controller`.

![Ethernet Board]({{ site.url }}/images/posts/arduino-ethernet-board.jpg)

The first thing I did was look up the datasheet for the [ENC28J60 Ethernet controller](http://ww1.microchip.com/downloads/en/DeviceDoc/39662e.pdf). I was looking for detailed information on what each of the Ten interface pins on the board did and was happy to find that almost all the information I needed was available in the document provided.

Some of the key features the controller offers that I'm interested in are:

1. `Fully Compatible with 10/100/1000Base-T Networks` - The interface can provide full gigabit speeds.

2. `Supports Full and Half-Duplex modes` - Bi-directional simultaneous communication can occur on the same port, though I don't think the Arduino won't be-able to utilize this due to its single core/one operation at a time limitation.

3.  `SPI Interface with Clock Speeds up to 20 MHz` - SPI (Serial Peripheral Interface) will be the main way I communicate with the module. I already know there's a very extensive [SPI library](https://www.arduino.cc/en/Reference/SPI) available that I can learn with.

4. `8-Kbyte Transmit/Receive Packet Dual Port SRAM` - Allows for latching (in SRAM // Static random-access memory) and queuing of packets and data when up to 8-Kbytes. Again, I don't think this will be relevant to me but it's still nice to know about.

5.  `Supports Unicast, Multicast and Broadcast Packets` - Self explanatory and expected on most interfaces these days.

6. `WOL or Magic Packet` - Wake on LAN, another neat feature I'd love to explore on the board.

## Pin Description

Below is the schematic provided for the `ENC28J60 Ethernet controller`. There are only a couple pins that we have direct access to via the Pin headers, I'll try to explain as best I can what each of these pins are and what they do.

![Ethernet Controller Schematic]({{ site.url }}/images/posts/arduino-controller-schem.png)

1. `CLKOUT` - The Programmable clock output pin is provided for use as the host controller clock or as a clock source for other devices in the system.
* Has an internal `Prescaler` which can divide the output by 1, 2, 3, 4 or 8. A `Prescaler` is used to reduce a high frequency electrical signal to a lower frequency by integer division.

2. `INT` - Interrupt output pin signals the occurrence of an interrupt event to the host controller.

3. `WOL` - Wake on Lan pin which can be used to push a magic packet through to the Ethernet interface connected. There's some interesting examples of this [here](http://playground.arduino.cc/Main/ArduinoWaker).

4. `SO` - Also defined as `MISO (Master In Slave Out)` and is used as the Slave line for sending data to the master. The master in this case is normally the Arduino or microcontroller.

5. `SI` - Also defined as `MOSI (Master Out Slave In)` and is used as the Master line for sending data to the peripherals.

6. `SCK` - The Serial clock which synchronizes the data transmission generated by the master.

7. `CS` - Chip select the input pin for the SPI interface. It is held low while any operation is performed and returned high when finished.

8. `RESET` - Active low device that resets the input.

9. `VCC` - 3.3V supply input.

10. `GND` - Grounding pin.

If you're interested in the full block diagram for the controller, it can be seen below. Take note of the various pin labels we just discussed and use them to work out how the system all comes together.

![Controller Block Diagram]({{ site.url }}/images/posts/arduino-controller-block-diagram.png)

## Serial Peripheral Interface (SPI)

Commands and data are sent to the device via the `SI pin`, with data being clocked in on the rising edge of `SCK`. Data is driven out on the `SO line` on the falling edge of `SCK`. The `CS pin` must be held low while any operation is performed and returned high when finished.

Below is a timeline displaying the Pin states for both input and output.

![Input Output]({{ site.url }}/images/posts/arduino-controller-input-output.png)

These interfaces are mapped to the following ports on the Arduino Uno. You can find the correct pins for other boards under Connections [here](https://www.arduino.cc/en/Reference/SPI). Note that the ENC28J60 controller uses a different pin for CS than the normal pin 10 (SS).

1. `SI` Pin -> Digital `Pin 11` OR `ICSP-4`

2. `SO` Pin -> Digital `Pin 12` OR `ICSP-1`

3. `SCK` Pin -> Digital `Pin 13` OR `ICSP-3`

4. `CS` Pin -> Digital `Pin 8`

`NOTE` You can also use the Reset, Ground and 3.3V pins on the ICSP interface. Else just use the normal pins. You can safely ignore the `RESET pin` for most examples.

![ICSP]({{ site.url }}/images/posts/arduino-controller-icsp.png)

## Ethercard Libraries + Examples

In order to get our device communicating we'll need to use a library called `Ethercard`. It can be downloaded from here:

{% highlight c %}
https://github.com/jcw/ethercard
{% endhighlight c %}

Once you've downloaded the zip, place the contents in your Arduino `libraries` folder. The contents of the `ethercard` folder comes with a couple examples that we'll be using to first confirm that our interfacing is correct.

Go ahead and open up the `testDHCP sketch` under examples and upload the code to your Arduino. Connect a networked Ethernet cable to your Ethernet module and fire up the serial monitor. You will also need to set the `baud rate to 57600` (as specified in the code).

If all went well you should receive the following serial output indicating that you've successfully been assigned a DHCP address (your IP values will vary obviously).

{% highlight c %}
[testDHCP]
MAC: 74:69:69:2D:30:31
Setting up DHCP
MyIP: 192.168.188.53
Netmask: 255.255.255.0
GW IP: 192.168.188.254
DNS IP: 192.168.188.254
{% endhighlight c %}

Yay! We got it working. That's a really simple example though, and we still don't really know how it's working. Next we'll take a look at the code and try to build our own code from scratch.

## Build a Webserver

Lets open a new project and begin. Start by adding the appropriate code to include the EtherCard library:

{% highlight c %}
#include <EtherCard.h>
{% endhighlight c %}

Next we'll setup a place where we can specify static IP information. We'll do that by creating and populating the following byte arrays with relevant IP network information

{% highlight c %}
// Ethernet interface ip address
static byte myip[] = { 192,168,188,200 };
// Gateway ip address
static byte gwip[] = { 192,168,188,254 };
// DNS ip address
static byte dnsip[] = { 192,168,188,254 };
// Subnet mask
static byte mask[] = { 255,255,255,0 };
{% endhighlight c %}

Add a another byte array to store the mac address of the interface. You can either make up one yourself or obtain the interfaces actual address from the board itself. If you can't be bothered with either of these things feel free to use mine.

{% highlight c %}
// Ethernet mac address - must be unique on your network
static byte mymac[] = { 0x74,0x69,0x69,0x2D,0x30,0x31 };
{% endhighlight c %}

I would also recommend adding the following line to specify the TCP/IP buffer size. We will be using this later during the interface initialization.

{% highlight c %}
// TCP/IP send and receive buffer
byte Ethernet::buffer[500];
{% endhighlight c %}

Now lets get started on the setup() code. We'll start by opening up a serial connection for debugging with the baud rate of 57600

{% highlight c %}
void setup() {
  Serial.begin(57600);
  Serial.println("\n[Debugger]");
{% endhighlight c %}

Now we need to initialize the Ethernet interface using the `ether.begin()` function. If we have a look at the functions definition in the `EtherCard.h` file we can see what values it accepts.

{% highlight c %}
    /**   @brief  Initialize the network interface
    *     @param  size Size of data buffer
    *     @param  macaddr Hardware address to assign to the network interface (6 bytes)
    *     @param  csPin Arduino pin number connected to chip select. Default = 8
    *     @return <i>uint8_t</i> Firmware version or zero on failure.
    */
    static uint8_t begin (const uint16_t size, const uint8_t* macaddr,
                          uint8_t csPin =8);
{% endhighlight c %}

We can use the information above to construct the ether.begin() function using the Ethernet buffer size and our Ethernet mac address. We also want to wrap this initialization in an `if statement` to confirm the interface is constructed correctly. Use the following syntax to get that done:

{% highlight c %}
if (ether.begin(sizeof Ethernet::buffer, mymac) == 0)
    Serial.println( "Failed to access Ethernet controller");
{% endhighlight c %}

Next we need to setup the interface with either DHCP or the static values we declared earlier on. You can choose to do either by implementing one of the following solutions:

`DHCP`
{% highlight c %}
ether.dhcpSetup()
{% endhighlight c %}

`Static` implementation is defined in `EtherCard.h`

{% highlight c %}
/**   @brief  Configure network interface with static IP
*     @param  my_ip IP address (4 bytes). 0 for no change.
*     @param  gw_ip Gateway address (4 bytes). 0 for no change. Default = 0
*     @param  dns_ip DNS address (4 bytes). 0 for no change. Default = 0
*     @param  mask Subnet mask (4 bytes). 0 for no change. Default = 0
*     @return <i>bool</i> Returns true on success - actually always true
*/
static bool staticSetup (const uint8_t* my_ip,
                         const uint8_t* gw_ip = 0,
                         const uint8_t* dns_ip = 0,
                         const uint8_t* mask = 0);
{% endhighlight c %}

And therefore can be implemented as follows:

{% highlight c %}
ether.staticSetup(myip, gwip, dnsip, mask);
{% endhighlight c %}

At this point, we should have our interface setup. Just to make sure lets write out the IP values to serial:

{% highlight c %}
ether.printIp("IP:  ", ether.myip);
ether.printIp("GW:  ", ether.gwip);  
ether.printIp("DNS: ", ether.dnsip);
{% endhighlight c %}
